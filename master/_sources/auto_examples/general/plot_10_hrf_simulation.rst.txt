
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/general/plot_10_hrf_simulation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_general_plot_10_hrf_simulation.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_general_plot_10_hrf_simulation.py:


.. _tut-fnirs-hrf-sim:

GLM Analysis (Simulated)
=============================

In this example we simulate a block design
functional near-infrared spectroscopy (fNIRS)
experiment and analyse
the simulated signal. We investigate the effect additive noise and
measurement length has on response amplitude estimates.

.. contents:: Page contents
   :local:
   :depth: 2

.. GENERATED FROM PYTHON SOURCE LINES 18-34

.. code-block:: default

    # sphinx_gallery_thumbnail_number = 3

    # Authors: Robert Luke <mail@robertluke.net>
    #
    # License: BSD (3-clause)

    import mne
    import mne_nirs
    import matplotlib.pylab as plt
    import numpy as np
    from mne_nirs.experimental_design import make_first_level_design_matrix
    from mne_nirs.statistics import run_GLM
    from nilearn.plotting import plot_design_matrix
    np.random.seed(1)









.. GENERATED FROM PYTHON SOURCE LINES 35-43

Simulate noise free NIRS data
-----------------------------

First we simulate some noise free data. We simulate 5 minutes of data with a
block design. The inter stimulus interval of the stimuli is uniformly
selected between 15 and 45 seconds.
The amplitude of the simulated signal is 4 uMol and the sample rate is 3 Hz.
The simulated signal is plotted below.

.. GENERATED FROM PYTHON SOURCE LINES 43-52

.. code-block:: default


    sfreq = 3.
    amp = 4.

    raw = mne_nirs.simulation.simulate_nirs_raw(
        sfreq=sfreq, sig_dur=60 * 5, amplitude=amp, isi_min=15., isi_max=45.)
    raw.plot(duration=300, show_scrollbars=False)





.. image-sg:: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_001.png
   :alt: plot 10 hrf simulation
   :srcset: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    <MNEBrowseFigure size 640x480 with 4 Axes>



.. GENERATED FROM PYTHON SOURCE LINES 53-59

Create design matrix
------------------------------------

Next we create a design matrix based on the annotation times in the simulated
data. We use the nilearn plotting function to visualise the design matrix.
For more details on this procedure see :ref:`tut-fnirs-hrf`.

.. GENERATED FROM PYTHON SOURCE LINES 59-67

.. code-block:: default


    design_matrix = make_first_level_design_matrix(raw, stim_dur=5.0,
                                                   drift_order=1,
                                                   drift_model='polynomial')
    fig, ax1 = plt.subplots(figsize=(10, 6), nrows=1, ncols=1)
    fig = plot_design_matrix(design_matrix, ax=ax1)





.. image-sg:: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_002.png
   :alt: plot 10 hrf simulation
   :srcset: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 68-77

Estimate response on clean data
-------------------------------

Here we run the GLM analysis on the clean data.
The design matrix had three columns, so we get an estimate for our simulated
event, the first order drift, and the constant.
We see that the estimate of the first component is 4e-6 (4 uM),
which was the amplitude we used in the simulation.
We also see that the mean square error of the model fit is close to zero.

.. GENERATED FROM PYTHON SOURCE LINES 77-85

.. code-block:: default


    glm_est = run_GLM(raw, design_matrix)

    print("Estimate:", glm_est['Simulated'].theta[0],
          "  MSE:", glm_est['Simulated'].MSE,
          "  Error (uM):", 1e6*(glm_est['Simulated'].theta[0] - amp*1e-6))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Estimate: [4.e-06]   MSE: [1.52643584e-42]   Error (uM): [3.38813179e-15]




.. GENERATED FROM PYTHON SOURCE LINES 86-96

Simulate noisy NIRS data (white)
--------------------------------

Real data has noise. Here we add white noise, this noise is not realistic
but serves as a reference point for evaluating the estimation process.
We run the GLM analysis exactly as in the previous section
and plot the noisy data and the GLM fitted model.
We print the response estimate and see that is close, but not exactly correct,
we observe the mean square error is similar to the added noise.
Note that the clean data plot is so similar to the GLM estimate that it is hard to see unless zoomed in. 

.. GENERATED FROM PYTHON SOURCE LINES 96-115

.. code-block:: default


    # First take a copy of noise free data for comparison
    raw_noise_free = raw.copy()

    raw._data += np.random.normal(0, np.sqrt(1e-11), raw._data.shape)
    glm_est = run_GLM(raw, design_matrix)

    plt.plot(raw.times, raw_noise_free.get_data().T * 1e6)
    plt.plot(raw.times, raw.get_data().T * 1e6, alpha=0.3)
    plt.plot(raw.times, glm_est['Simulated'].theta[0] * design_matrix["A"].values * 1e6)
    plt.xlabel("Time (s)")
    plt.ylabel("Haemoglobin (uM)")
    plt.legend(["Clean Data", "Noisy Data", "GLM Estimate"])

    print("Estimate:", glm_est['Simulated'].theta[0],
          "  MSE:", glm_est['Simulated'].MSE,
          "  Error (uM):", 1e6*(glm_est['Simulated'].theta[0] - amp*1e-6))





.. image-sg:: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_003.png
   :alt: plot 10 hrf simulation
   :srcset: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Estimate: [3.85152156e-06]   MSE: [9.4081311e-12]   Error (uM): [-0.14847844]




.. GENERATED FROM PYTHON SOURCE LINES 116-124

Simulate noisy NIRS data (colored)
----------------------------------

Here we add colored noise which better matches what is seen with real data.
Again, the same GLM procedure is run.
The estimate is reported below, and even though the signal was difficult to
observe in the raw data, the GLM analysis has extracted an accurate estimate.
However, the error is greater for the colored than white noise.

.. GENERATED FROM PYTHON SOURCE LINES 124-149

.. code-block:: default


    raw = raw_noise_free.copy()
    cov = mne.Covariance(np.ones(1) * 1e-11, raw.ch_names,
                         raw.info['bads'], raw.info['projs'], nfree=0)
    raw = mne.simulation.add_noise(raw, cov,
                                   iir_filter=[1., -0.58853134, -0.29575669,
                                               -0.52246482, 0.38735476,
                                               0.02428681])
    design_matrix = make_first_level_design_matrix(raw, stim_dur=5.0,
                                                   drift_order=1,
                                                   drift_model='polynomial')
    glm_est = run_GLM(raw, design_matrix)

    plt.plot(raw.times, raw_noise_free.get_data().T * 1e6)
    plt.plot(raw.times, raw.get_data().T * 1e6, alpha=0.3)
    plt.plot(raw.times, glm_est['Simulated'].theta[0] * design_matrix["A"].values * 1e6)
    plt.xlabel("Time (s)")
    plt.ylabel("Haemoglobin (uM)")
    plt.legend(["Clean Data", "Noisy Data", "GLM Estimate"])

    print("Estimate:", glm_est['Simulated'].theta[0],
          "  MSE:", glm_est['Simulated'].MSE,
          "  Error (uM):", 1e6*(glm_est['Simulated'].theta[0] - amp*1e-6))





.. image-sg:: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_004.png
   :alt: plot 10 hrf simulation
   :srcset: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Adding noise to 1/1 channels (1 channels in cov)
    Estimate: [5.6774337e-06]   MSE: [4.703062e-10]   Error (uM): [1.6774337]




.. GENERATED FROM PYTHON SOURCE LINES 150-157

How does increasing the measurement length affect estimation accuracy?
----------------------------------------------------------------------

The easiest way to reduce error in your response estimate is to collect more
data. Here we simulated increasing the recording time to 30 minutes.
We run the same analysis and observe that the error is reduced from
approximately 0.6 uM for 5 minutes of data to 0.25 uM for 30 minutes of data.

.. GENERATED FROM PYTHON SOURCE LINES 157-183

.. code-block:: default


    raw = mne_nirs.simulation.simulate_nirs_raw(
        sfreq=sfreq, sig_dur=60 * 30, amplitude=amp, isi_min=15., isi_max=45.)
    cov = mne.Covariance(np.ones(1) * 1e-11, raw.ch_names,
                         raw.info['bads'], raw.info['projs'], nfree=0)
    raw = mne.simulation.add_noise(raw, cov,
                                   iir_filter=[1., -0.58853134, -0.29575669,
                                               -0.52246482, 0.38735476,
                                               0.02428681])

    design_matrix = make_first_level_design_matrix(raw, stim_dur=5.0,
                                                   drift_order=1,
                                                   drift_model='polynomial')
    glm_est = run_GLM(raw, design_matrix)

    plt.plot(raw.times, raw.get_data().T * 1e6, alpha=0.3)
    plt.plot(raw.times, glm_est['Simulated'].theta[0] * design_matrix["A"].values * 1e6)
    plt.xlabel("Time (s)")
    plt.ylabel("Haemoglobin (uM)")
    plt.legend(["Noisy Data", "GLM Estimate"])

    print("Estimate:", glm_est['Simulated'].theta[0],
          "  MSE:", glm_est['Simulated'].MSE,
          "  Error (uM):", 1e6*(glm_est['Simulated'].theta[0] - amp*1e-6))





.. image-sg:: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_005.png
   :alt: plot 10 hrf simulation
   :srcset: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Adding noise to 1/1 channels (1 channels in cov)
    Estimate: [6.84350151e-06]   MSE: [1.14130839e-09]   Error (uM): [2.84350151]




.. GENERATED FROM PYTHON SOURCE LINES 184-193

Using autoregressive models in the GLM to account for noise structure
---------------------------------------------------------------------

An auto regressive noise model can be used account for temporal structure
in the noise. To account for the noise properties in the example above,
a fifth order auto regressive model is used below. Given this
is a simulation, we can verify if the correct estimate of the noise
properties was extracted from the data and if this
improved the response estimate.

.. GENERATED FROM PYTHON SOURCE LINES 193-204

.. code-block:: default


    glm_est = run_GLM(raw, design_matrix, noise_model='ar5')

    fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(15, 6))
    plt.plot([-0.58853134, -0.29575669, -0.52246482, 0.38735476, 0.02428681],
             axes=axes)  # actual values from model above
    plt.plot(glm_est['Simulated'].model.rho * -1.0,  axes=axes)  # estimates
    plt.legend(["Simulation AR coefficients", "Estimated AR coefficients"])
    plt.xlabel("Coefficient")





.. image-sg:: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_006.png
   :alt: plot 10 hrf simulation
   :srcset: /auto_examples/general/images/sphx_glr_plot_10_hrf_simulation_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    Text(0.5, 36.72222222222221, 'Coefficient')



.. GENERATED FROM PYTHON SOURCE LINES 205-207

We can see that the estimates from the GLM AR model are quite accurate,
but how does this affect the accuracy of the response estimate?

.. GENERATED FROM PYTHON SOURCE LINES 207-212

.. code-block:: default


    print("Estimate:", glm_est['Simulated'].theta[0],
          "  MSE:", glm_est['Simulated'].MSE,
          "  Error (uM):", 1e6*(glm_est['Simulated'].theta[0] - amp*1e-6))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Estimate: [4.26283431e-06]   MSE: [9.88198782e-12]   Error (uM): [0.26283431]




.. GENERATED FROM PYTHON SOURCE LINES 213-215

The response estimate using the AR(5) model is more accurate than the
AR(1) model (error of 0.25 vs 2.8 uM).

.. GENERATED FROM PYTHON SOURCE LINES 217-228

Conclusion?
-----------

In this example we have generated a noise free signal containing simulated
haemodynamic responses. We were then able to accurately estimate the amplitude
of the simulated signal. We then added noise and illustrated that the
estimate provided by the GLM was correct, but contained some error. We
observed that as the measurement time was increased, the estimated
error decreased.
We also observed in this idealised example that including an appropriate
model of the noise can improve the accuracy of the response estimate.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  6.846 seconds)

**Estimated memory usage:**  38 MB


.. _sphx_glr_download_auto_examples_general_plot_10_hrf_simulation.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/rob-luke/mne-nirs-docker/main?filepath=examples/mne-nirs-website-examples/auto_examples/general/plot_10_hrf_simulation.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_10_hrf_simulation.py <plot_10_hrf_simulation.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_10_hrf_simulation.ipynb <plot_10_hrf_simulation.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
